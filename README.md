Cryptography
============

Encrypting files before storage in the cloud.

Dependencies
------------

1. Crypto++ Library
2. Linux

Project Structure
-----------------

1. Preprocess : on input a key k, and a file f1 with filename fn1, returns a related file f2 with a related filename fn2.
2. Authorize : on input a key k and a filename fn1, returns a string fk and a filename fn3.
3. Recover : on input a file f2 with filename fn2, and string fk, returns a file f3.

What has been done
------------------

  In this project, the target is to encrypt the file before posting it on the storage server. Encrypting the file and leaving the same name may not be a good idea (from a privacy point of view) since file names sometimes reveal the file content. Accordingly, in Preprocess we assign a new name fn2 to the encrypted file. Moreover, encrypting all files with the same key is not a good idea as later we want to selectively authorize decryption of some but not all of the files. Accordingly, we generate an encryption key fk for each file as a function of the key k and the original file name fn1. After Preprocess is run, we post the encrypted file with the new name into the storage server.
  
  At this point, others could download or copy the encrypted file, but only those we choose can decrypt it. Thus, we run Authorize to regenerate fk from k and fn1 just as done in Preprocess, and generate fn3 just as we generated fn2 in Preprocess (thus, fn3=fn2). Now we could send fk to our desired peer.
  
  Our peer can use fk received from us and the encrypted file downloaded from the storage server, to run Recover and successfully decrypt the file.
  
Primitives Used
---------------

1. *Preprocess* : AES in CFB Mode with 128bit Key Length + Random Hex Generator.
2. *Authorize* : Random Hex Generator + RSA + HMAC.
3. *Recover* : HMAC Verification then decryption.

Technical Detals
----------------

1. **PreProcess**
    * Preprocess takes as input: key.txt, file.txt (F1) with filename.txt (Fn1).
    * It outputs efile.txt (F2) with efilename.txt (Fn2).
    * The Key (K) and initialization vector (IV) are dynamically generated by the crypto++ library.
    * file.txt (F1) is encrypted with **AES** encryption in **CFB mode** to generate efile.txt (F2).
    * eFilename.txt (Fn2) is generated as follows:    
        `Fn1 XOR (random hex generator = KFN), gives us Fn2.`
    * The Key K, IV and KFN are now stored in key.txt file.
    * We now generate **HMAC** of file efile.txt (F2) with key Kmac and store it in filename hmac_efilename.txt.
    * The key Kmac for HMAC is also stored in the key.txt file.

2. **Authorize**
    * Authorize Stage takes as input Key.txt (K) and Filename.txt (Fn1).
    * It gives as output, fkey.txt (FK) and sfilename.txt (Fn3).
    * We use random generator KFN from the key.txt file which we stored in the PreProcess stage.
    * Sfilename.txt (Fn3) is generated by 
        `Fn1 XOR KFN.`
    * FK is generated as follows
        `Kmac + KFN +[(K + IV) XOR Fn1]`

3. **Recover**
    * We transfer the symmetric key FK and HMAC of efile.txt to the user using asymmetric encryption that is via secure channel     implemented with **RSA**.
    * We use this HMAC to verify for integrity by using the key Kmac stored in FK.
    * Once we verify that the integrity of the file is not compromised, we move forward with decryption of the file.
    * Once the user receives the symmetric key he can now proceed with the decryption of the file.
    * Decryption of the file is as follows:-
        1. `We first remove KFN from FK.`
        2. `KFN XOR Fn2 = Fn1`
        3. Now, once we get Fn1, we can use
        4. `(K + IV) = F(K) XOR Fn1`
        5. Once we derive (K + IV) we can now get sfile.txt (F3), plaintext file from efile.txt(F2) by using the decryption             algorithm in AES crypto++ library.
  
Improvements
------------

We can improve this system by encrypting any type of file apart from only text.
